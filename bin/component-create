#!/usr/bin/env node

/**
 * Module dependencies.
 */

var program = require('commander');
var component = require('..');
var utils = component.utils;
var path = require('path');
var fs = require('fs');
var join = path.join;
var basename = path.basename;
var extname = path.extname;
var read = fs.readFileSync;
var readdir = fs.readdirSync;
var exists = fs.existsSync;
var mkdir = require('mkdirp').sync;
var readme = require('../templates/readme');

// usage

program.usage('[dir]');

// options

program
  .option('-l, --local', 'create a local private component')
  .parse(process.argv);

// config

var conf = {};

// dest

var dir = program.args[0] || '.';

// --local

var local = program.local;

// already a component

if (exists(join(dir, 'component.json'))) {
  utils.fatal(dir + ' is already a component');
}

/**
 * Verbose write.
 */

function write(path, str) {
  if (exists(path)) {
    utils.warn('exists', path);
  } else {
    utils.log('create', path);
    fs.writeFileSync(path, str);
  }
}

// private / public prompts

if (local) {
  var prompt = {
    name: 'name: ',
    desc: 'description: ',
    js: 'does this component have js? ',
    css: 'does this component have css? ',
    html: 'does this component have html? '
  };
} else {
  var prompt = {
    repo: 'repo (username/project): ',
    desc: 'description: ',
    js: 'does this component have js? ',
    css: 'does this component have css? ',
    html: 'does this component have html? '
  };
}

// prompt

program.prompt(prompt, function(obj){
  if (local) {
    var name = obj.name;
  } else {
    // repo
    var repo = obj.repo.split('/');
    if (2 != repo.length) throw new Error('repo must be <username>/<project>');

    // name
    var name = repo[1];
  }

  // populate json
  conf.name = obj.name = name;
  if (!local) conf.repo = repo.join('/');
  conf.description = obj.desc;
  if (!local) conf.version = "0.0.1";
  if (!local) conf.keywords = [];
  conf.dependencies = {};
  conf.development = {};
  if (!local) conf.license = "MIT";

  // dir
  console.log();
  utils.log('create', dir);
  mkdir(dir);

  // js
  if (yes(obj.js)) {
    conf.main = "index.js";
    conf.scripts = ["index.js"];
    write(join(dir, 'index.js'), '');
  } else if(!no(obj.js)) {
    conf.main = obj.js;
    conf.scripts = [obj.js];
    write(join(dir, obj.js), '');
  }

  // html
  if (yes(obj.html)) {
    conf.templates = ['template.html'];
    write(join(dir, 'template.html'), '');
  } else if(!no(obj.html)) {
    conf.templates = [obj.html];
    write(join(dir, obj.html), '');
  }

  // css
  if (yes(obj.css)) {
    conf.styles = [name + '.css'];
    write(join(dir, name + '.css'), '');
  } else if(!no(obj.css)) {
    conf.styles = [obj.css];
    write(join(dir, obj.css), '');
  }

  // makefile
  if (!local) write(join(dir, 'Makefile'), createMakefile(obj));

  // readme
  if (!local) write(join(dir, 'Readme.md'), readme(obj));

  // changelog
  if (!local) write(join(dir, 'History.md'), '');

  // .gitignore
  if (!local) write(join(dir, '.gitignore'), 'components\nbuild\n');

  // write component.json
  write(join(dir, 'component.json'), JSON.stringify(conf, null, 2));

  console.log();
  process.exit();
});

/**
 * Booleans from `str`.
 */

function yes(str) {
  return /^y(es)?/i.test(str);
}

function no(str) {
  return /^n(o)?/i.test(str);
}

/**
 * Create a makefile.
 */

function createMakefile(obj) {
  var buf = '\n';
  var tpl = basename(obj.html, extname(obj.html));

  // build target
  buf += 'build: components';
  if (yes(obj.js)) buf += ' index.js';
  else if (!no(obj.js)) buf += ' ' + obj.js;

  if (yes(obj.css)) buf += ' ' + obj.name + '.css';
  else if (!no(obj.css)) buf += ' ' + obj.css;

  if (yes(obj.html)) buf += ' template.html';
  else if (!no(obj.html)) buf += ' ' + obj.html;
  buf += '\n\t@component build --dev\n\n';

  // components target
  buf += 'components: component.json\n';
  buf += '\t@component install --dev\n\n';

  // clean phony
  buf += 'clean:\n';
  buf += '\trm -fr build components template.js\n\n';

  // PHONY
  buf += '.PHONY: clean\n';

  return buf;
}
